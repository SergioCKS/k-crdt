//! # HLC
//!
//! Implementation of a hybrid logical clock. A hybrid logical clock has the following properties:
//!
//!   * **Physical time tracking.** HLC timestamps are kept close to physical time.
//!   * **One way causality tracking.** If an event `b` can be causally tracked back to another one
//!     `a`, then the timestamp assigned to `a` is smaller than the one assigned to `b`.
//!   * **Bounded timestamps.** The size of timestamps is small and constant (64-bits).
//!   * **Monotonically increasing time.** Time updates are monotonically increasing, even on the
//!     face of NTP kinks and leap seconds.
//!
//! ### Usage in a distributed system
//!
//! Each node in the system runs an HLC instance which has access to a local time source.
//! Every HLC keeps track of the last accepted time, which may be ahead of local time,
//! but the drift is kept bounded.
//!
//! **Timestamping local events.** When an event occurs, the local time is polled:
//!
//! If the local time is ahead of the last accepted time, the last accepted time is updated.
//!
//! If the local time is equal to or behind of the last accepted time,
//! the last accepted time is kept, but its counter part is increased.
//!
//! The updated last accepted timestamp is associated with the event.
//!
//! **Broadcasting events.** New events are sent in messages to the other nodes with their
//! corresponding timestamps.
//!
//! Upon message transmission, a new timestamp is generated and associated with the message.
//!
//! Upon reception, the HLC on the receiving end has to update its
//! last accepted time by polling the local time source and acting as follows:
//!
//! If the message timestamp is too far ahead into the future, the update is rejected.
//! Otherwise, the last accepted time, the newly polled time and the message time are compared.
//!
//! If the last accepted time is ahead of both the newly polled time and the message time,
//! it is kept but the counter is increased.
//!
//! If the newly polled time is ahead, it is taken as the new last accepted time (with counter 0).
//!
//! If the message time is ahead, it is taken as the new last accepted time and
//! its counter is increased.
//!
//! Reference: [Logical Physical Clocks and Consistent Snapshots in Globally Distributed Databases - Kulkarni et. al.](https://cse.buffalo.edu/tech-reports/2014-04.pdf)
//!
//! ### Technical details
//!
//! **Time source.** An HLC relies on a source of physical time that is capable of generating [`Timestamp`]s
//! based on a physical clock. In this implementation, the time source is abstracted as a function
//! that is provided on HLC creation.
//!
//! **Timestamps.** The timestamps used are NTP timestamps in which the last 8 bits are used as a
//! counter. The documentation in the [`Timestamp`] module provides more details about the timestamp
//! implementation.
//!
//! **Maximum drift.** An update with a timestamp that lies further in the future than both the
//! current polled time and the last accepted time is accepted as long as the time drift is below
//! a specific bound. This guarantees that the time of the HLC cannot drift indefinitely into the
//! future. This way, the timestamps generated by the HLC are kept close to physical time.
//!
//! **Offset.** It is possible to pass an offset to the local time polling function. This is useful
//! if the local time sources of nodes are not reliable but the time difference with a more reliable
//! source can be calculated.
//!
//! **Handling update rejections.** When a message timestamp drifts too far ahead into the future,
//! the message is rejected. The emitting node should be notified of rejections, so that it adjusts
//! it's clock/offset, and retries the rejected updates.
use crate::time::{Clock, Timestamp};
use std::cmp;
use std::fmt::Debug;
use std::time::Duration;

/// ## Maximum drift
///
/// Maximum allowed time drift in nanoseconds.
///
/// Updates with timestamps with time larger than NOW + MAX_DRIFT are rejected.
const MAX_DRIFT: u32 = 100_000_000; // 100 milliseconds

/// ## Hybrid Logical Clock (Trait)
///
/// An HLC maintains a timestamp corresponding to the last accepted time which must can be
/// accessed (`get_last_time`), updated (`set_last_time`) and whose counter can be
/// increased (`increase_counter`). These methods depend on the internal implementation of the
/// struct, so no default implementations are provided.
///
/// On top of this, an HLC must be able to generate timestamps (`generate_timestamp`) and
/// update the last accepted time on message reception (`update_with_timestamp`). These methods
/// require access to a time source (a `Clock`). For a given clock, generic implementations are
/// provided.
///
/// * The [`Default`] trait is required, as no constructor is otherwise assumed.
pub trait HybridLogicalClock<T: Clock>: Default {
    /// ### Get last time
    ///
    /// Returns the timestamp corresponding to the last accepted time.
    fn get_last_time(&self) -> Timestamp;

    /// ### Set last time
    ///
    /// Update the last accepted time.
    fn set_last_time(&mut self, new_time: Timestamp);

    /// ### Get internal clock
    ///
    /// Returns the internal clock used to poll time.
    fn get_internal_clock(&self) -> T;

    /// ### Increase counter
    ///
    /// Increases the counter of the timestamp.
    fn increase_counter(&mut self) {
        self.get_last_time().increase_counter()
    }

    /// ### Generate timestamp
    ///
    /// Generates a new timestamp polling the physical time source.
    ///
    /// #### Usage example
    ///
    /// ```rust
    /// use crdts::time::hlc::{HybridLogicalClock, SysTimeHLC};
    ///
    /// let mut hlc = SysTimeHLC::default();
    ///
    /// let ts1 = hlc.generate_timestamp().unwrap();
    /// let ts2 = hlc.generate_timestamp().unwrap();
    ///
    /// assert!(ts1 < ts2);
    /// ```
    fn generate_timestamp(&mut self) -> Timestamp {
        let now_ts = self.get_internal_clock().poll_time();

        let now_time = now_ts.get_time();
        let last_time = self.get_last_time().get_time();
        if now_time > last_time {
            // Time moves forward: Update and reset counter.
            self.set_last_time(now_ts);
        } else {
            // Going back in time: Increase counter.
            self.increase_counter();
        }
        self.get_last_time()
    }

    /// ### Update clock with external timestamp and offset
    ///
    /// Given another timestamp (usually from another node), update clock time.
    ///
    /// If the time drifts too much into the future, the update is rejected.
    ///
    /// * Returns timestamp after the update or update error.
    ///
    /// #### Usage example
    ///
    /// ```rust
    /// use crdts::time::hlc::{SysTimeHLC,HybridLogicalClock};
    ///
    /// let mut hlc1 = SysTimeHLC::default();
    /// let mut hlc2 = SysTimeHLC::default();
    ///
    /// let other_ts = hlc2.generate_timestamp().unwrap();
    /// hlc1.update_with_timestamp(other_ts).unwrap();
    ///
    /// let ts = hlc1.generate_timestamp().unwrap();
    ///
    /// assert!(ts > other_ts);
    /// ```
    fn update_with_timestamp(
        &mut self,
        other_ts: Timestamp,
    ) -> Result<Timestamp, UpdateWithTimestampError> {
        let last_ts = self.get_last_time();
        let now_ts = self.get_internal_clock().poll_time();

        let now_duration = now_ts.get_duration();
        let other_duration = other_ts.get_duration();

        if other_duration > now_duration
            && other_duration - now_duration > Duration::new(0, MAX_DRIFT)
        {
            Err(UpdateWithTimestampError::DriftTooLarge)
        } else {
            let max_ts = cmp::max(last_ts, cmp::max(now_ts, other_ts));
            if max_ts == last_ts {
                // Both current and message time go back in time: Maintain last time and increase counter.
                self.increase_counter();
            } else if max_ts == now_ts {
                // Time has moved forward and message time is behind: Update time and reset counter.
                self.set_last_time(now_ts);
            } else {
                // max_ts == msg_ts
                // Message time moves forward and drift is acceptable: Take message time and increase counter.
                self.set_last_time(other_ts);
                self.increase_counter();
            }
            Ok(self.get_last_time())
        }
    }
}

#[derive(Debug)]
pub enum UpdateWithTimestampError {
    DriftTooLarge,
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use crate::time::{clock::tests::SysTimeClock, Offset};

    //#region SysTimeHLC
    /// ## System time HLC
    ///
    /// HLC relying on [`SystemTime`] as time source.
    #[derive(Clone, Copy, Default)]
    pub struct SysTimeHLC {
        /// ### Last time
        ///
        /// Last accepted time as HLC/NTP timestamp.
        last_time: Timestamp,

        /// ### Clock
        ///
        /// Internal clock used for polling time.
        clock: SysTimeClock,
    }

    impl SysTimeHLC {
        pub fn get_offset(&self) -> Offset {
            self.clock.get_offset()
        }

        pub fn set_offset(&mut self, offset: Offset) -> () {
            self.clock.set_offset(offset)
        }
    }

    impl HybridLogicalClock<SysTimeClock> for SysTimeHLC {
        fn get_last_time(&self) -> Timestamp {
            self.last_time
        }

        fn set_last_time(&mut self, new_time: Timestamp) {
            self.last_time = new_time;
        }

        fn get_internal_clock(&self) -> SysTimeClock {
            self.clock
        }
    }
    //#endregion

    #[test]
    fn timestamp_generation_works() {
        let mut hlc = SysTimeHLC::default();

        let ts1 = hlc.generate_timestamp();

        let ts2 = hlc.generate_timestamp();

        assert!(ts1 < ts2, "Timestamps should increase monotonically.");
    }

    #[test]
    fn update_with_timestamp_works() {
        let mut hlc1 = SysTimeHLC::default();
        let mut hlc2 = SysTimeHLC::default();

        let other_ts = hlc2.generate_timestamp();
        hlc1.update_with_timestamp(other_ts);

        let ts = hlc1.generate_timestamp();

        assert!(
            ts > other_ts,
            "Timestamps generated after update should be larger."
        );
    }

    // #[test]
    // fn drift_is_limited() {
    //     let mut hlc = SysTimeHLC::default();
    //
    //     let ts1 = hlc.generate_timestamp()
    //         .expect("Timestamp generation with system time should work.");
    //
    //     // By shifting the clock backwards a couple of seconds, the timestamp should lie too far
    //     // into the future and be rejected.
    //     hlc.set_offset(Offset::Negative(Duration::new(2, 0))).unwrap();
    //     if let UpdateWithTimestampError::DriftTooLarge(msg) = hlc.update_with_timestamp(ts1 )
    //         .expect_err("Timestamps too far into the future should be rejected.") {
    //         assert!(msg.contains(&MAX_DRIFT.to_string()), "The error message should indicate the maximum allowed drift.");
    //     } else {
    //         panic!("Incorrect error type: Expected `UpdateWithTimestampError::DriftTooLarge`.")
    //     }
    // }
}
