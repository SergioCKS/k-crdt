//! # HLC
//!
//! Implementation of a hybrid logical clock. A hybrid logical clock has the following properties:
//!
//!   * **Physical time tracking.** HLC timestamps are kept close to physical time.
//!   * **One way causality tracking.** If an event `b` can be causally tracked back to another one
//!     `a`, then the timestamp assigned to `a` is smaller than the one assigned to `b`.
//!   * **Bounded timestamps.** The size of timestamps is small and constant (64-bits).
//!   * **Monotonically increasing time.** Time updates are monotonically increasing, even on the
//!     face of NTP kinks and leap seconds.
//!
//! ### Usage in a distributed system
//!
//! Each node in the system runs an HLC instance which has access to a local time source.
//! Every HLC keeps track of the last accepted time, which may be ahead of local time,
//! but the drift is kept bounded.
//!
//! **Timestamping local events.** When an event occurs, the local time is polled:
//!
//! If the local time is ahead of the last accepted time, the last accepted time is updated.
//!
//! If the local time is equal to or behind of the last accepted time,
//! the last accepted time is kept, but its counter part is increased.
//!
//! The updated last accepted timestamp is associated with the event.
//!
//! **Broadcasting events.** New events are sent in messages to the other nodes with their
//! corresponding timestamps.
//!
//! Upon message transmission, a new timestamp is generated and associated with the message.
//!
//! Upon reception, the HLC on the receiving end has to update its
//! last accepted time by polling the local time source and acting as follows:
//!
//! If the message timestamp is too far ahead into the future, the update is rejected.
//! Otherwise, the last accepted time, the newly polled time and the message time are compared.
//!
//! If the last accepted time is ahead of both the newly polled time and the message time,
//! it is kept but the counter is increased.
//!
//! If the newly polled time is ahead, it is taken as the new last accepted time (with counter 0).
//!
//! If the message time is ahead, it is taken as the new last accepted time and
//! its counter is increased.
//!
//! Reference: [Logical Physical Clocks and Consistent Snapshots in Globally Distributed Databases - Kulkarni et. al.](https://cse.buffalo.edu/tech-reports/2014-04.pdf)
//!
//! ### Technical details
//!
//! **Time source.** An HLC relies on a source of physical time that is capable of generating [`Timestamp`]s
//! based on a physical clock. In this implementation, the time source is abstracted as a function
//! that is provided on HLC creation.
//!
//! **Timestamps.** The timestamps used are NTP timestamps in which the last 8 bits are used as a
//! counter. The documentation in the [`Timestamp`] module provides more details about the timestamp
//! implementation.
//!
//! **Maximum drift.** An update with a timestamp that lies further in the future than both the
//! current polled time and the last accepted time is accepted as long as the time drift is below
//! a specific bound. This guarantees that the time of the HLC cannot drift indefinitely into the
//! future. This way, the timestamps generated by the HLC are kept close to physical time.
//!
//! **Offset.** It is possible to pass an offset to the local time polling function. This is useful
//! if the local time sources of nodes are not reliable but the time difference with a more reliable
//! source can be calculated.
//!
//! **Handling update rejections.** When a message timestamp drifts too far ahead into the future,
//! the message is rejected. The emitting node should be notified of rejections, so that it adjusts
//! it's clock/offset, and retries the rejected updates.
use crate::time::{
    clock::{Offsetted as COffsetted, SysTimeClock, MAX_OFFSET},
    Offset,
};
use crate::time::{Clock, Timestamp};
use std::cmp;
use std::fmt::Debug;
use std::time::Duration;

/// ## Maximum drift
///
/// Maximum allowed time drift in nanoseconds.
///
/// Updates with timestamps with time larger than NOW + MAX_DRIFT are rejected.
const MAX_DRIFT: u32 = 100_000_000; // 100 milliseconds

/// ## Hybrid Logical Clock (trait)
///
/// An HLC maintains a timestamp corresponding to the last accepted time which must can be
/// accessed (`get_last_time`), updated (`set_last_time`) and whose counter can be
/// increased (`increase_counter`). These methods depend on the internal implementation of the
/// struct, so no default implementations are provided.
///
/// On top of this, an HLC must be able to generate timestamps (`generate_timestamp`) and
/// update the last accepted time on message reception (`update_with_timestamp`). These methods
/// require access to a time source (a `Clock`). For a given clock, generic implementations are
/// provided.
///
/// * The [`Default`] trait is required, as no constructor is otherwise assumed.
pub trait HybridLogicalClock<T: Clock>: Default {
    /// ### Get last time
    ///
    /// Returns the timestamp corresponding to the last accepted time.
    fn get_last_time(&self) -> Timestamp;

    /// ### Set last time
    ///
    /// Update the last accepted time.
    fn set_last_time(&mut self, new_time: Timestamp);

    /// ### Get internal clock
    ///
    /// Returns the internal clock used to poll time.
    fn get_internal_clock(&self) -> T;

    /// ### Increase counter
    ///
    /// Increases the counter of the timestamp.
    fn increase_counter(&mut self) {
        let mut ts = self.get_last_time();
        ts.increase_counter();
        self.set_last_time(ts);
    }

    /// ### Generate timestamp
    ///
    /// Generates a new timestamp polling the physical time source.
    ///
    /// #### Usage example
    ///
    /// ```rust
    /// use crdts::time::hlc::{HybridLogicalClock, SysTimeHLC};
    ///
    /// let mut hlc = SysTimeHLC::default();
    ///
    /// let ts1 = hlc.generate_timestamp();
    /// let ts2 = hlc.generate_timestamp();
    ///
    /// assert!(ts1 < ts2, "Timestamps should increase monotonically.");
    /// ```
    fn generate_timestamp(&mut self) -> Timestamp {
        let now_ts = self.get_internal_clock().poll_time();

        let now_time = now_ts.get_time();
        let last_time = self.get_last_time().get_time();
        if now_time > last_time {
            // Time moves forward: Update and reset counter.
            self.set_last_time(now_ts);
        } else {
            // Going back in time: Increase counter.
            self.increase_counter();
        }
        self.get_last_time()
    }

    /// ### Update clock with external timestamp and offset
    ///
    /// Given another timestamp (usually from another node), update clock time.
    ///
    /// If the time drifts too much into the future, the update is rejected.
    ///
    /// * Returns timestamp after the update or update error.
    ///
    /// #### Usage example
    ///
    /// ```rust
    /// use crdts::time::hlc::{SysTimeHLC, HybridLogicalClock};
    ///
    /// let mut hlc1 = SysTimeHLC::default();
    /// let mut hlc2 = SysTimeHLC::default();
    ///
    /// let other_ts = hlc2.generate_timestamp();
    /// hlc1.update_with_timestamp(other_ts).unwrap();
    ///
    /// let ts = hlc1.generate_timestamp();
    ///
    /// assert!(ts > other_ts, "Timestamps should be larger after update.");
    /// ```
    fn update_with_timestamp(
        &mut self,
        other_ts: Timestamp,
    ) -> Result<Timestamp, UpdateWithTimestampError> {
        let last_ts = self.get_last_time();
        let now_ts = self.get_internal_clock().poll_time();

        let now_duration = now_ts.get_duration();
        let other_duration = other_ts.get_duration();

        if other_duration > now_duration
            && other_duration - now_duration > Duration::new(0, MAX_DRIFT)
        {
            Err(UpdateWithTimestampError::DriftTooLarge)
        } else {
            let max_ts = cmp::max(last_ts, cmp::max(now_ts, other_ts));
            if max_ts == last_ts {
                // Both current and message time go back in time: Maintain last time and increase counter.
                self.increase_counter();
            } else if max_ts == now_ts {
                // Time has moved forward and message time is behind: Update time and reset counter.
                self.set_last_time(now_ts);
            } else {
                // max_ts == msg_ts
                // Message time moves forward and drift is acceptable: Take message time and increase counter.
                self.set_last_time(other_ts);
                self.increase_counter();
            }
            Ok(self.get_last_time())
        }
    }
}

/// Offsetted HLC (trait)
///
/// Similar to clocks, HLCs can also expose an interface for getting/setting the offset of their
/// internal clock, regardless of whether the internal clock implements the corresponding Offsetted
/// trait or not.
pub trait Offsetted<T: Clock>: HybridLogicalClock<T> {
    /// ### Get offset
    ///
    /// Retrieves the current offset of the HLC.
    fn get_offset(&self) -> Offset;

    /// ### Set offset (unchecked)
    ///
    /// Directly updates the offset of the HLC without checking the allowed limit.
    fn set_offset_unchecked(&mut self, offset: Offset) -> ();

    /// ### Set offset
    ///
    /// Updates the offset of the HLC.
    /// If the limit is exceeded, the limit is used instead (saturating behaviour).
    fn set_offset(&mut self, offset: Offset) -> () {
        let offset = if offset.as_millis().abs() > MAX_OFFSET {
            Offset::from_millis(offset.as_millis().signum() * MAX_OFFSET)
        } else {
            offset
        };

        self.set_offset_unchecked(offset);
    }
}

//#region SysTimeHLC
/// ## System time HLC
///
/// HLC relying on [`SystemTime`] as time source.
#[derive(Clone, Copy, Default)]
pub struct SysTimeHLC {
    /// ### Last time
    ///
    /// Last accepted time as HLC/NTP timestamp.
    last_time: Timestamp,

    /// ### Clock
    ///
    /// Internal clock used for polling time.
    clock: SysTimeClock,
}

impl Offsetted<SysTimeClock> for SysTimeHLC {
    fn get_offset(&self) -> Offset {
        self.clock.get_offset()
    }

    fn set_offset_unchecked(&mut self, offset: Offset) -> () {
        self.clock.set_offset(offset)
    }
}

impl HybridLogicalClock<SysTimeClock> for SysTimeHLC {
    fn get_last_time(&self) -> Timestamp {
        self.last_time
    }

    fn set_last_time(&mut self, new_time: Timestamp) {
        self.last_time = new_time;
    }

    fn get_internal_clock(&self) -> SysTimeClock {
        self.clock
    }
}
//#endregion

#[derive(Debug)]
pub enum UpdateWithTimestampError {
    DriftTooLarge,
}

//#region Generic tests
/// ## HLC - Generate timestamp works
///
/// Tests if a generic HLC can be instantiated and generates monotonically increasing timestamps.
pub fn hlc_generate_timestamp_works<U: Clock, T: HybridLogicalClock<U>>() {
    let mut hlc = T::default();

    let ts1 = hlc.generate_timestamp();
    let ts2 = hlc.generate_timestamp();

    assert!(ts1 < ts2, "Timestamps should increase monotonically.");
}

/// ## HLC - Update with timestamp works
///
/// Tests an interaction between two generic HLCs in which one is updated with a timestamp
/// generated by the other.
pub fn hlc_update_with_timestamp_works<U: Clock, T: HybridLogicalClock<U>>() {
    let mut hlc1 = T::default();
    let mut hlc2 = T::default();

    let other_ts = hlc2.generate_timestamp();
    hlc1.update_with_timestamp(other_ts).unwrap();

    let ts = hlc1.generate_timestamp();

    assert!(
        ts > other_ts,
        "Timestamps generated after update should be larger."
    );
}

/// ## HLC - Drift is limited
///
/// Tests that a generic HLC rejects updates if timestamp drifts too far into the future.
pub fn hlc_drift_is_limited<U: Clock, T: HybridLogicalClock<U>>() {
    let mut hlc = T::default();

    let ts = hlc.generate_timestamp();
    let ts = Timestamp::from(ts.get_duration() + Duration::new(2, 0));

    // By shifting the clock backwards a couple of seconds, the timestamp should lie too far
    // into the future and be rejected.
    // hlc.set_offset(Offset::from_millis(-2_000));

    if let Err(UpdateWithTimestampError::DriftTooLarge) = hlc.update_with_timestamp(ts) {
        ()
    } else {
        panic!("Incorrect error type: Expected `UpdateWithTimestampError::DriftTooLarge`.")
    }
}
//#endregion

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn timestamp_generation_works() {
        hlc_generate_timestamp_works::<SysTimeClock, SysTimeHLC>();
    }

    #[test]
    fn update_with_timestamp_works() {
        hlc_update_with_timestamp_works::<SysTimeClock, SysTimeHLC>();
    }

    #[test]
    fn drift_is_limited() {
        hlc_drift_is_limited::<SysTimeClock, SysTimeHLC>();
    }
}
